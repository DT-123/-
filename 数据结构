一、绪论
  1、数据元素的存储结构方式：顺序存储结构、链式存储结构
   顺序存储：把数据元素存放在地址连续的单元里，其数据间的逻辑关系和物理关系是一致的。  比如：数组。
   链式存储：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的也可以是不连续的。
            这就说明链式存储结构的数据元素存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，通过地址可找到相关联数据元素的位置。 
  2、数据元素是数据的基本单位。一个数据元素可由若干个数据项组成，数据项是数据的不可分割的最小单位。
  3、数据对象是性质相同的数据元素的集合。
  4、数据结构是相互之间存在一种或多种特定关系的数据元素的集合。                                                                               
二、算法
  1、算法的五个特点：有穷性、确定性、可行性、输入、输出。
  2、算法优劣度量：时间复杂度、空间复杂度。
      O（n）  一阶n  二阶n*n  ...
三、线性表
1、线性表：是n个数据元素构成的有限序列。
   eg：（1 2 3 4 5 6...n）  
   前驱元素：2为3的前驱元素；3为2的后继元素。
   线性表元素的个数定义为线性表的长度，n=0时为空表。
2、线性表由第一个元素记为1，不像 数组 首元素是tmp[0]。
3、线性表的顺序表示：用一组地址连续的存储单元依次存储线性表的数据元素。
4、线性表顺序存储结构的优缺点：线性表的顺序存储结构在存、读数据时，不管是哪个位置，时间复杂度都是O（1）。
                            而在插入或删除时，时间复杂度都是O（n）。 
      这就说明它比较适合元素个数比较稳定，不经常插入和删除元素，更多的是存取数据操作。
5、线性表的链式存储结构：用一组任意的存储单元存储线性表的数据元素，此存储单元不仅要存储数据元素信息，还要存储它的
                       后继元素的存储地址（指针）。
                       数据域：存储数据元素信息的域。
                       指针域：存储直接后继位置的域。
                       指针域中存储的信息成为指针或链。
                       指针域+数据域，组成数据元素的存储映像，称为结点。
                       链表有限长度，有头有尾，链表中第一个结点的存储位置叫做头指针，最后一个结点指针为空。
6、头指针：指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。
          头指针具有标识作用，常用头指针冠以链表的名字。
          无论链表是否为空，头指针均不为空。
          头指针是链表的必要元素。
7、头结点：头结点是为了操作的统一和方便设立的，防灾第一个元素的节点之前，其数据域一般无意义。
          有了头结点，对在第一元素结点前插入结点和删除第一结点的操作与对其他结点的操作就统一了。
          头结点不一定是链表的必须要素。
8、用C语言的结构指针描述单链表：
          typedef struct Node
          {
            ElemType data;    //数据域
            struct Node *Next;  //指针域
          }Node；          
9、单链表的读取：从头开始找，直到第i个元素为止。
               算法的时间复杂度取决于i的位置。当i=1时，不需要遍历，当i=n时需要遍历n-1次，复杂度为O（n）
               单链表的结构中没有定义表长，所以不知道要循环多少次，不可用for循环。
               核心思想：工作指针后移。
10、单链表的插入：在结点a和b之间插入结点x，假设s为指向结点x的指针，p为指向结点a的指针
        typedef struct Node *LinkList；   //结构体定义如8
        Status ListInsert_L(LinkList &L,int i,ElemType) //在带头结点的单链线性表L中第i个位置插入元素e
        {
          p=L；j=0；
          while(p&&j<i-1)      //此处为什么是&不是|，p为指针，p+1应该是指针移动一位，p&1有意义？   
          {
            p=p->next;++j;      //寻找第i-1个结点。此处++j和j++都可以吧，没有影响
          }
          if(!p||j>i-1) retern ERROR; //i小于1或者大于表长+1则返回错误
          s=(LinkList)malloc(sizeof(LNode))  //malloc生成新结点函数；sizeof定义一个灵活的地址，不同类型的
                                             //LNode对应不同的大小地址；最后LinkList强制类型转换
          s->data=e;s->next=p->next;  //把e元素赋给s的数据域，p->next是结点b的地址，赋给s的next
          p->next=s;                  //把x的地址s赋给结点a的p->next
          return OK;
        }
11、单链表的删除与插入原理相同，都是操作指针，比如要删除ab之间的x，需要将a的next直接指向b就行
    （a->next=x->next->next）。
12、单链表存在的意义：假设要从第i个位置开始插入连续10个元素；
                    若用顺序存储结构，每一次插入都需要移动n-i个位置，所以每次都是O（n）；
                    若用链式存储结构，只需要第一次时找到第i个位置的指针，此时为O（n），之后的都是对指针赋值
                    移动，时间复杂度为O（1）。
13、单链表的整表创建：顺序存储结构即数组；链式存储是一个动态生成链表的过程。
            单链表创建思路：
                    ——声明一结点p和计数器变量i
                    ——初始化一个空链表L
                    ——让L的头结点的指针指向NULL，即建立一个带头结点的单链表
                    ——循环实现后继结点的赋值和插入
14、（*L）->next=NULL;    此处*L要加括号，*的优先级比->优先级低。
15、头插法创建单链表：
        void CreateList_L(LinkList &L,int n)
        {
          L=(LinkList)malloc(sizeof(LNode));
          L->next=NULL; //先建立一个带头结点的单链表
          for(i=n;i>0;--i)
            {
              p=(LinkList)malloc(sizeof(LNode)); //生成新结点
              scanf(&p->data);   //输入元素值
              p->next=L->next;   //L的next指向NULL，现在把它赋给新结点P的next，即新结点p变成指向头结点的第一个结点
              L->next=p;         //再把P赋给L的next，L变成第二个结点
            }
        }
     头插法生成的链表中结点的次序和输入的顺序相反。
 16、尾插法重点：r->next=p;   //p为即将到来的下一个临时结点，把即将到来的p赋给当前的r的next
                r=p;         //让刚来的p变成新的r，循环下去就变成了尾插法
 17、单链表和顺序存储结构总结：
                  ——若线性表需要频繁查找，很少需要插入和删除操作时，宜采用顺序存储结构。
                  ——若需要频繁插入和删除，宜采用单链表结构。
            实例：LOL中用户的账号ID很少更改或删除，应该用顺序存储。
                  每把出的装备都是不一样的，还会卖出，这个用单链表结构。
                  ——当线性表中的元素个数变化较大或者不知道有多大时，考虑用链式存储，这样不用考虑存储空间。
18、静态链表：
        ——数组的第一个和最后一个元素做特殊处理，他们的data不存放数据。
        ——把未使用的数组元素称为备用链表。
        ——数组的第一个元素，即下标为0的元素的游标（cur）用来存放备用链表的第一个结点的下标。
        ——数组的最后一个元素，即下标为MAXSIZE-1的cur存放第一个有数值的元素的下标，相当于单链表中头结点的作用。

 

          

          
          
          
          
          
          
          
          
